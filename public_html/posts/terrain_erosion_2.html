<html>
<head>
	<link rel="stylesheet" type="text/css" href="../style.css">
	<title>Axel Paris</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
	<meta http-equiv="Content-type" content="text/html; charset=utf-8"/> 
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
	<link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>  
  <body>
	<br>
	<center>
		<a href="../../index.html" style="text-decoration: none;font-size:1.2em"><b>Axel Paris - PhD Student in Computer Graphics</b>
		<br>
		<hr style="width:20em;">
		</a>
		<a class="aUnderlined" href="../../index.html">Home</a> &nbsp;
		<a class="aUnderlined" href="../publications.html">Publications</a> &nbsp;
		<a class="aUnderlined" href="../cv.html">Resume</a> &nbsp;
		<a class="aUnderlined" href="mailto:axel.paris69@gmail.com">Email</a> &nbsp;
		<a class="aUnderlined" href="https://twitter.com/Axel_Paris">Twitter</a>
		<br>
	</center>
	<br>
	<div>
	<h2>Terrain Erosion on the GPU #2</h2>
	February 14, 2020.
	</div>
	<hr>
	In my <a class="aUnderlined" href="terrain_erosion.html">previous post</a> on thermal erosion, I tried to implement the naive, straightforward version of the algorithm which
	can be summarized as this: for every vertex v, check if v is unstable in regards to its neighbours. If so, distribute
	a certain amount of material to some of the downwards neighbours.
	<br><br>
	The problem with this approach when in a massively parallel context is that we need to write to neighboring cells, which
	leads to slow atomic operations. However, for several algorithms, what often works is to reverse the thinking: instead
	of trying to write to neighboring indices in an array, change the method to <i>read</i> from neighbours and <i>only write</i> to
	myself, therefore avoiding costly atomic operations and race conditions.
	<br><br>
	By chance, it is simple to apply this method to thermal erosion. Here is the revised version of the algorithm:<br><br>
	
	<br>
	The idea can be generally applied to other erosion method such as hydraulic erosion.
	Now the main bottleneck of this approach is the constant read operations occuring in each thread of the shader. Reading from a storage
	buffer is not as bad as performing a texture sample, but still.
	<br><br>
	Here is a performance comparison of the method described in this post versus the one from the previous post:
	<br><br>
	The new method outperforms the one from the <a class="aUnderlined" href="terrain_erosion.html">previous post</a> and has no race condition.
	
	<h3> References </h3>

	<br>
	<hr>
 <center>